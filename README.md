# rust-visual-engine (visual_diff_engine)

A compact visual-difference engine and preprocessing toolkit written primarily in Rust with a few Python helper scripts. The project detects and analyzes visual differences between video frames (or images), extracts events, and provides utilities for preprocessing, rotation / deformation analysis, and cropping.

This README documents what the repository contains, what each major file and folder does, and how to build and run the project locally.

## High-level purpose

- Ingest video or image frames, compute visual differences between frames, and produce structured event data (cropped regions, metadata JSON, and visual artifacts).
- Provide preprocessing utilities (frame extraction, rotation/flow analysis) to prepare inputs for the engine.
- Keep the core engine fast and self-contained in Rust; use small Python scripts for specialized preprocessing/analysis where convenient.

## Key features

- Frame differencing and event extraction pipeline implemented in Rust.
- Small Python utilities for deformation/rotation analysis and other preprocessing tasks.
- Example data and output directories included to show expected input/output layout.

## Repository layout (important files and directories)

Top-level files
- `Cargo.toml`, `Cargo.lock` — Rust project manifest and lockfile.
- `README.md` — this file.
- `input.mp4` — example or test input video (if present).
- `yolov8n.pt`, `yolov8s.pt`, `yolov9n.pt` (and other model weights) — pre-trained model weights used by preprocessing or detection scripts. These are large binary files and should normally be kept out of git using `.gitignore`.
- `deform_analyzer.py` — Python script for deformation analysis.
- `rotation_flow.py` — Python script that appears to compute rotation flow or similar motion analysis.

Top-level directories
- `src/` — Rust source code for the engine and supporting modules. Key files:
	- `main.rs` — program entry point.
	- `engine.rs` — core engine logic for orchestrating preprocessing, diffing and event extraction.
	- `diff.rs` — code implementing image/region differencing.
	- `event.rs` — structures and helpers for representing events (cropped images, metadata JSON, etc.).
	- `ipc.rs` — inter-process / inter-component communication helpers.
	- `preprocess.rs` — Rust-side preprocessing helpers for frames and images.

- `frames/` — example or working frames (image sequence). Files like `frame_0001.png` etc.
- `processed/` — processed outputs corresponding to `frames/`.
- `events/` — output events collected by the engine. Example structure:
	- `event_0001/`
		- `crop.png` — cropped region for the event
		- `curr.png` / `prev.png` — frame snapshots used to derive the event
		- `ml.json` — metadata or ML outputs for the event

- `target/` — Rust build output (compiled binaries). This is generated and should be ignored in source control.

Example images
- `refined_crop_43299.png`, `refined_crop_43330.png`, ... — example refined crop images generated by the pipeline.

Notes about large files and git
- Model weights (for example `yolov8n.pt`, `yolov8s.pt`, `yolov9n.pt`) are large binaries. The repository contains a `.gitignore` that excludes common model weight names and `*.pt`. Keep weight files out of git history to save space. If you need to share them, use a release asset, Git LFS, or an external storage bucket.

## Build & run (Rust)

Prerequisites
- Rust toolchain (stable) — install via rustup: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
- Recommended: `cargo` (comes with rustup)

Quick build

```bash
# from repository root
cargo build --release

# run the compiled binary (the package is configured with `main.rs`, so `cargo run` should also work)
cargo run --release -- <args>
```

Notes
- The exact CLI arguments and behavior are implemented in `src/main.rs`. If you need to pass an input file or output directory, inspect `main.rs` or run `cargo run -- --help`.

## Preprocessing & Python scripts

The repository includes a couple of Python utilities used as helpers or offline tools:

- `deform_analyzer.py` — analyze shape deformation between images/frames. Likely depends on numpy, OpenCV (cv2), and possibly PyTorch or other libraries if it uses ML models.
- `rotation_flow.py` — compute rotation or optical flow related analysis.

Suggested Python environment and dependencies (example)

```bash
python3 -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install numpy opencv-python torch torchvision
```

Run a script example

```bash
python deform_analyzer.py --input frames/frame_0001.png --output out.json
```

Adjust the command-line flags according to the script internals (open the top of each script to see its `argparse` options).

## Example workflow

1. Place model weights (if needed) at the repository root or a configured path. Make sure `.gitignore` excludes them.
2. Prepare frames (e.g., extract frames from `input.mp4` into `frames/`) or place your images into `frames/`.
3. Optionally run Python preprocessing (rotation/flow/deformation) to generate auxiliary metadata.
4. Build and run the Rust engine to detect differences and write events into `events/`.

## Tests & validation

- There are no unit tests included by default in the repository root. If you add tests, use `cargo test` to run them.

## Contributing

- Please open issues or pull requests for bug fixes and features.
- Keep large binary model files out of git. Use Git LFS or external storage for model assets.

## Troubleshooting

- If the build fails, ensure you have a recent Rust toolchain installed and that native dependencies (if any) are present on macOS (for example `pkg-config`, `cmake`, or system-level libs used by image crates).
- If Python scripts fail to import modules, create the venv and install the suggested dependencies.

## Notes & TODOs

- Add an explicit `requirements.txt` or `pyproject.toml` for the Python helpers.
- Add a `LICENSE` file indicating the project's license.
- Document exact CLI flags in `main.rs` and add a short examples section here.

## Contact / Author

- Repository owner: `Yashbhu` (seen in repository metadata).

---

If you want, I can also:
- generate a `requirements.txt` for the Python scripts by scanning imports,
- add a short example `Makefile` or convenience script to run the full pipeline locally,
- or open a PR to the remote repository with the updated `README.md`.
